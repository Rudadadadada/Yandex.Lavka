# Вступительное задание Python в ШБР

## Реализовано:

### Задание 1

#### Реализованы следующие ручки:

##### order-controller

1. ``POST /orders`` - загрузка заказов в базу данных.
2. ``POST /orders/complete`` - помечает заказ выполненным.  **Примечание:** Response openapi и enrollmet'а различаются. В openapi нужно дублировать request, а в enrollment написано, что нужно выводить только индентификатор. Сделано согласно openapi.
3. ``GET /orders`` - возвращает информацию о заказах, в том числе их id и время, когда заказ был доставлен (если не был доставлен, время доставки = null).
4. ``GET /orders/{order_id}`` - возвращает информацию о заказе по id, в том числе время, когда заказ был доставлен (если не был доставлен, время доставки = null).

##### courier-controller

1. ``POST /couriers`` - загрузка курьеров в базу данных.
2. ``GET /couriers`` - возвращает информацию о курьерах, в том числе их id.
3. ``GET /couriers/{courier_id}`` - возвращает информацию о курьере по id. 

### Задание 2

#### Реализованы следующие ручки:

##### courier-controller

1. ``GET /couriers/meta-info/{courier_id}`` - возвращает заработок и рейтинг курьера.

### Задание 3

#### Реализация Rate limiter

Сделано с использованием библиотеки sloawapi. RPS = 10 на каждую ручку.

Конфигурации rate limiter находятся в файле ``app/limiter``

````
limiter = Limiter(key_func=get_remote_address) 
LIMIT = "10/second"
````

### Задание 4

#### Реализованы следующие ручки:

##### order-controller

1. ``POST /orders/assign`` - распределяет заказы по курьерам.

##### courier-controller

1. ``GET /couriers/assignments`` - возвращает информацию о распределении заказов по курьерам.

***Важно***: все ручки имеют определенную валидацию, поэтому нужно отправлять корректные данные, чтобы было
200 ОК. 

Например, в ручке POST /orders/complete есть валидация времени. Если курьер не работает в переданное время или заказ не
может быть принят в переданное время, то будет 400 Bad request. Также время начала должно быть <= времени конца.

## Запуск:

1. Чтобы собрать Dockerfile нужно воспользоваться командой:

``docker build . -t app:latest``

2. Чтобы собрать и запустить docker-compose нужно воспользоваться командой:

``docker compose up -d --build``

## Идея алгоритма и мысли:
### Идея алгоритма
Задача распределения заказов по курьерам является нетривиальной и NP-полной. В ходе прочтения 
множественных статей на разных языках, появилось много идей для реализации алгоритма: 
1. Задача о назначениях и венгерский алгоритм
2. Эволюционные алгоритмы
3. Мультипликативный рюкзак
4. Алгоритмы с использованием линейного программирования

Для решения задачи, я постарался выполнить приближенный алгоритм для мультипликативного рюкзака 
с использованием жадного алгоритма на основе некоторой метрики и двух указателей. При помощи метрики, 
мы можем сделать сортировку подходящих (удовлетворяющих всем требованиям курьера) заказов, а затем жадно, 
но верно, распределять заказы по группам одному курьеру. Для того, чтобы выполнить условие задачи 
(минимализировать стоимость доставки), при помощи двух указателей я набираю заказы в следующем порядке: 
вначале берем первый заказ (самый дешевый и самый срочный), а затем к нему пытаемся набрать оставшиеся 
заказы с конца отсортированного списка (самые дорогие и не самые срочные). Донабор происходит согласно 
размеру группы и согласно вместимости курьера (рюкзака).Так как типов курьеров много, то данный алгоритм 
нужно выполнить для каждого типа курьеров (3 раза). Таким образом, мы с некоторой точностью постараемся и
минимизировать стоимость доставки, и выполнить как можно больше заказов.

***Важно***: чтобы тестировать распределение, нужно менять дату распределения вручную. 
Дата по дефолту = сегодняшему дню. Также нужно менять валидацию времени, поскольку у меня сделано, 
что дата распределения <= текущий день (логично).

### Мысли
Во время выполнения задания, я много раз сталкивался с проблемой различия openapi и enrollment'a, пришлось
задавать вопросы в чат-боте, но там, к сожалению, мне отвечали как будто совсем не то, что нужно. Поэтому
некоторые моменты в работе выполнены по-своему или согласно openapi, в котором не всегда было понятно, что
происходит. Например, мне так и не ответили про дубляж ответов в ручках post couriers/ и post orders/.

Очень странная ручка post complete/orders, в которой я могу передавать любое время выполненного заказа.
В чат-боте мне ответили, что время выполненного заказа != времени распределенного. Это, в целом, логично, но
хотелось бы получить больше информации про это сразу, например, получить какой-нибудь коэффициент 
"хорошего курьера", который может опаздывать или приходить раньше, например, в интервале +- 10 минут.

Почему я не могу передавать дату распределения? Это очень сильно усложняет тестирование, поскольку нужно
лезть в код и вручную менять.

Подводя итоги, хочется сказать, что проект выдался большим, во время его выполнения я освежил и дополнил свои
знания в разработке REST-API сервисов. Надеюсь, это решение Вам понравится, и я смогу принять участие в проекте
ШБР, о котором так сильно мечтаю. Спасибо!